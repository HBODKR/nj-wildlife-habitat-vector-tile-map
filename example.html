<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>NJ Habitat</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    
    <!-- Mapbox GL JS -->
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.42.2/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.42.2/mapbox-gl.css' rel='stylesheet' />
    
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    
    <!-- Turf.js -->
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>
    
    <!-- Mapbox GL JS Draw -->
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.0/mapbox-gl-draw.js'></script>
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.0/mapbox-gl-draw.css' type='text/css'/>
    
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>

<div id='map'></div>

<script>

// Read-scope Mapbox Access Token for account with uploaded tile sources
const MAPBOX_ACCESS_TOKEN = 'pk.eyJ1IjoiYWFyb25kZW5uaXMiLCJhIjoiem5LLURoYyJ9.T3tswGTI5ve8_wE-a02cMw';

// Protocol, hostname, and port for application (e.g. http://localhost:8000)
const HOST = 'http://localhost:4000/app';

// URLs to the uploaded tile source TileJSON resources. Supported protocols are http:, https:, and mapbox://<mapid>.
const TILE_SOURCES = {
  habitatAreas: 'mapbox://aarondennis.habitat-areas-2017',
  habitatOverview: 'mapbox://aarondennis.sightings-2017',
  parcels: undefined
}

const NJ_MAP_LIMITS = {
  minZoom: 7,
  bounds: [[-76.151,38.638],[-73.128,41.572]]
}

const APP = {
  initialMapLoaded: false,
  mode: 'draw',
  areaOfInterest: { type: 'FeatureCollection', features: [] },
  contextFeatures: { type: 'FeatureCollection', features: [] },
  featuresOfInterest: { type: 'FeatureCollection', features: [] }
}

mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;
const MAP = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/satellite-streets-v9',
  zoom: 12,
  center: [-74.7988, 40.61251],
  hash: true,
  minZoom: NJ_MAP_LIMITS.minZoom,
  maxBounds: NJ_MAP_LIMITS.bounds
});

MAP.addControl(new mapboxgl.NavigationControl());

// Setup drawing tool
const DRAW = new MapboxDraw({
  displayControlsDefault: false,
  controls: {
    polygon: true,
    trash: true
  }
});
MAP.addControl(DRAW);

MAP.on('render', updateApp);
MAP.on('moveend', updateApp);

// Listen for updates to the drawing
MAP.on('draw.create', updateAreaOfInterest);
MAP.on('draw.delete', updateAreaOfInterest);
MAP.on('draw.update', updateAreaOfInterest);

MAP.on('load', () => {
  APP.initialMapLoaded = true;
  
  // Add Habitats Areas
  MAP.addSource('habitats', {
    type: 'vector',
    url: TILE_SOURCES.habitatAreas
  });
  MAP.addLayer({
    "id": "habitat-areas-2017",
    "source": "habitats",
    "source-layer": "featurestxt",
    "minzoom": 12,
    "type": "fill",
    "paint": {
      "fill-color": "#be38ae",
      "fill-opacity": 0.4,
      "fill-outline-color": "#fff"
    }
  });

  // Add Sightings Overview
  MAP.addSource('sightings', {
    type: 'vector',
    url: TILE_SOURCES.habitatOverview
  });
  MAP.addLayer({
    "id": "sightings-2017",
    "source": "sightings",
    "source-layer": "sightings",
    "maxzoom": 12,
    "type": "circle",
    "paint": {
      'circle-radius': 3,
      'circle-color': '#fff',
      'circle-opacity': 0.8,
      'circle-blur': 1
    }
  });
});

function updateApp() {
  // determine if loaded
  if (APP.initialMapLoaded && MAP.loaded()) {
    setReady();
    
    let zoom = MAP.getZoom();
    
    if (zoom < 13) {
      // Render "Search for Address or Zoom to Region"
      renderZoomPrompt();
      APP.state = 0;
    } else if (zoom >= 13 && APP.areaOfInterest.features.length === 0 ) {
      // Render "Select Area of Interest"
      APP.state = 1;
      renderSelectAreaOfInterestPrompt();
    } else if (zoom >= 13 && APP.areaOfInterest.features.length > 0) {
      if (APP.state !== 2) {
        if (APP.featuresOfInterest.features.length > 0) {
          // Render "Display Area of Interest Analysis with Species List"
          APP.state = 2;
          renderAreaOfInterestReport();
        } else {
          setLoading();
        }
      }
    }
  } else {
    setLoading();
  }
}

function setReady() {
  //console.log('ready');
}

function setLoading() {
  //console.log('loading');
}

// Render Application State 0: Prompt user to zoom to an area of interest
function renderZoomPrompt() {}

// Render Application State 1: Prompt user to select an area of interest
function renderSelectAreaOfInterestPrompt() {}

// Render Application State 2: Report on user's selected area of interest
function renderAreaOfInterestReport() {
  console.log(JSON.stringify(APP.featuresOfInterest));
  APP.featuresOfInterest.features.map(function(f) {
    f.properties.species.map(function(s) {
      console.log(s);
    });
  });
}

function updateAreaOfInterest() {
  APP.areaOfInterest = turf.combine(DRAW.getAll());
  
  if (APP.areaOfInterest.features.length > 0) {
    
    frameMap();
    constrainMap();
    
    let tileFeatures = MAP.queryRenderedFeatures({ layers: [ 'habitat-areas-2017' ] });
    
    let tileFeatureLINKIDs = tileFeatures.map((feature) => { 
      return feature.properties.LINKID; 
    });
    
    let LINKIDs = tileFeatureLINKIDs.filter((id, index) => {
      return tileFeatureLINKIDs.indexOf(id) === index; 
    }).sort();
            
    // Download GeoJSON //
    // Initialize a queue of requests
    var q = d3.queue()
    // Make a request for the raw GeoJSON of each LINKID habitat
    for (var i = 0; i < LINKIDs.length; i++) {
      // Request GeoJSON files from `habitat` directory
      q.defer(d3.json, HOST + '/habitat/' + LINKIDs[i] + '.json')
    }
    // Wait for all the individual GeoJSON habitats to load
    q.awaitAll(function(error, data) {
      APP.contextFeatures = turf.featureCollection(data);
      
      let habitatData = APP.contextFeatures;
      let intersectionArea = APP.areaOfInterest.features[0];
      
      // Clip each feature in the FeatureCollection by the drawing's area of interest
      let intersectingHabitat = turf.featureCollection(habitatData.features.map((f) => {
        let clippedFeature = turf.intersect(intersectionArea, f);
        if (clippedFeature) { clippedFeature.properties = f.properties; }
        return clippedFeature; 
      }).filter(function(f) { return f; })); // Filter out null features (didn't intersect with area of interest)
      
      APP.featuresOfInterest = intersectingHabitat;
      
      updateApp();
    });
  } else {
    APP.contextFeatures = turf.featureCollection([]);
    APP.featuresOfInterest = turf.featureCollection([]);
    unconstrainMap();
    updateApp();
  }
}

function frameMap() {
  if (APP.areaOfInterest.features.length > 0) {
    let bounds = turf.bbox(APP.areaOfInterest);
    MAP.fitBounds(bounds, { duration: 0, padding: 50 }); // duration: 0 makes this synchronous
  }
}

// Limit the map zooming and panning to within the current frame
function constrainMap() {
  MAP.setMaxBounds(MAP.getBounds());
  MAP.setMinZoom(MAP.getZoom());
}

// Limit the map zooming and panning to only within NJ limits
function unconstrainMap() {
  MAP.setMaxBounds(NJ_MAP_LIMITS.bounds);
  MAP.setMinZoom(NJ_MAP_LIMITS.minZoom);
}

</script>

</body>
</html>